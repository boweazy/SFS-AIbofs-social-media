# path: requirements.txt
fastapi>=0.111
uvicorn[standard]>=0.30
pydantic>=2.7

# path: .gitignore
__pycache__/
*.pyc
data.json
.env

# path: .replit
run = """
pkill -f gunicorn >/dev/null 2>&1 || true
python3 -m pip install -U pip >/dev/null 2>&1
python3 -m pip install -r requirements.txt >/dev/null 2>&1
uvicorn main:app --host 0.0.0.0 --port 8000 --reload
"""
language = "python3"

# path: main.py
from __future__ import annotations

import os
import asyncio
import csv
import io
import json
import math
import re
import secrets
from dataclasses import asdict, dataclass, field
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Any, Dict, List, Literal, Optional, Tuple

from fastapi import FastAPI, HTTPException, Query, Header
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, StreamingResponse
from starlette.responses import FileResponse
from pydantic import BaseModel, Field

# ----- paths/env (why: avoid path/cwd issues) -----
BASE_DIR = Path(__file__).resolve().parent
STATIC_DIR = BASE_DIR / "static"
DATA_FILE = BASE_DIR / "data.json"
APP_ENV = os.getenv("APP_ENV", "dev")
RUN_SCHED = os.getenv("RUN_SCHEDULER", "true").lower() == "true"
ADMIN_TOKEN = os.getenv("ADMIN_TOKEN", "")  # simple admin guard
NOTIFY_WEBHOOK_URL = os.getenv("NOTIFY_WEBHOOK_URL", "")  # optional

# Optional LLM flags (kept stubbed here, but enforced via plan)
LLM_PROVIDER = os.getenv("LLM_PROVIDER", "").lower()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
LLM_MODEL = os.getenv("LLM_MODEL", "gpt-4o-mini")
LLM_INPUT_COST_PER_1K_GBP = float(os.getenv("LLM_INPUT_COST_PER_1K_GBP", "0.002"))
LLM_OUTPUT_COST_PER_1K_GBP = float(os.getenv("LLM_OUTPUT_COST_PER_1K_GBP", "0.006"))

# ----- plans/entitlements (why: sales + clear CX) -----
ENTITLEMENTS: Dict[str, Dict[str, Any]] = {
    "free": {"max_scheduled_per_month": 30,  "allow_openai": False, "name": "Free", "gbp_per_month": 0},
    "pro":  {"max_scheduled_per_month": 300, "allow_openai": True,  "name": "Pro",  "gbp_per_month": 29},
}

# ----- data models -----
@dataclass
class PostRecord:
    id: int
    platform: str
    content: str
    status: Literal["draft", "scheduled", "published", "failed"] = "scheduled"
    scheduled_time: Optional[str] = None
    external_id: Optional[str] = None
    error: Optional[str] = None
    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    updated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

@dataclass
class FeedbackRecord:
    id: int
    user: Optional[str]
    message: str
    meta: Optional[Dict[str, Any]] = None
    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

@dataclass
class NPSRecord:
    id: int
    score: int
    comment: Optional[str] = None
    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

@dataclass
class LeadRecord:
    id: int
    name: Optional[str]
    email: str
    message: Optional[str] = None
    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

@dataclass
class Referral:
    code: str
    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    uses: int = 0

@dataclass
class UserProfile:
    plan: str = "free"
    usage: Dict[str, int] = field(default_factory=dict)  # usage[YYYYMM] -> scheduled posts count
    onboarding_done: Dict[str, bool] = field(default_factory=lambda: {
        "connect_account": False, "generate_draft": False, "schedule_post": False
    })
    referral: Optional[Referral] = None
    flags: Dict[str, bool] = field(default_factory=dict)  # A/B flags

@dataclass
class State:
    next_post_id: int = 1
    posts: List[PostRecord] = field(default_factory=list)
    accounts: Dict[str, Dict[str, Optional[str]]] = field(default_factory=dict)
    profile: UserProfile = field(default_factory=UserProfile)
    next_feedback_id: int = 1
    feedback: List[FeedbackRecord] = field(default_factory=list)
    next_nps_id: int = 1
    nps: List[NPSRecord] = field(default_factory=list)
    next_lead_id: int = 1
    leads: List[LeadRecord] = field(default_factory=list)
    # allow template CRUD
    custom_templates: List[Dict[str, Any]] = field(default_factory=list)

# ----- storage -----
class Store:
    def __init__(self, file: Path):
        self.file = file
        self.lock = asyncio.Lock()
        if not file.exists():
            self._write(State())

    def _read(self) -> State:
        raw = json.loads(self.file.read_text() or "{}")
        if not raw:
            return State()
        posts = [PostRecord(**p) for p in raw.get("posts", [])]
        feedback = [FeedbackRecord(**f) for f in raw.get("feedback", [])]
        nps = [NPSRecord(**n) for n in raw.get("nps", [])]
        leads = [LeadRecord(**l) for l in raw.get("leads", [])]
        prof_raw = raw.get("profile") or {}
        referral = prof_raw.get("referral")
        profile = UserProfile(
            plan=prof_raw.get("plan", "free"),
            usage=prof_raw.get("usage", {}),
            onboarding_done=prof_raw.get("onboarding_done", {"connect_account": False, "generate_draft": False, "schedule_post": False}),
            referral=Referral(**referral) if referral else None,
            flags=prof_raw.get("flags", {})
        )
        return State(
            next_post_id=raw.get("next_post_id", 1),
            posts=posts,
            accounts=raw.get("accounts", {}),
            profile=profile,
            next_feedback_id=raw.get("next_feedback_id", 1),
            feedback=feedback,
            next_nps_id=raw.get("next_nps_id", 1),
            nps=nps,
            next_lead_id=raw.get("next_lead_id", 1),
            leads=leads,
            custom_templates=raw.get("custom_templates", []),
        )

    def _write(self, s: State) -> None:
        payload = {
            "next_post_id": s.next_post_id,
            "posts": [asdict(p) for p in s.posts],
            "accounts": s.accounts,
            "profile": {
                "plan": s.profile.plan,
                "usage": s.profile.usage,
                "onboarding_done": s.profile.onboarding_done,
                "referral": asdict(s.profile.referral) if s.profile.referral else None,
                "flags": s.profile.flags,
            },
            "next_feedback_id": s.next_feedback_id,
            "feedback": [asdict(f) for f in s.feedback],
            "next_nps_id": s.next_nps_id,
            "nps": [asdict(n) for n in s.nps],
            "next_lead_id": s.next_lead_id,
            "leads": [asdict(l) for l in s.leads],
            "custom_templates": s.custom_templates,
        }
        self.file.write_text(json.dumps(payload, ensure_ascii=False, indent=2))

    async def edit(self, fn):
        async with self.lock:
            s = self._read()
            res = fn(s)
            self._write(s)
            return res

    async def add_post(self, rec: PostRecord) -> PostRecord:
        def _fn(s: State):
            rec.id = s.next_post_id
            s.next_post_id += 1
            s.posts.append(rec)
            return rec
        return await self.edit(_fn)

    async def update_post(self, rec: PostRecord) -> None:
        def _fn(s: State):
            for i, p in enumerate(s.posts):
                if p.id == rec.id:
                    s.posts[i] = rec
                    break
        await self.edit(_fn)

    async def list_posts(self, status: Optional[str] = None) -> List[PostRecord]:
        async with self.lock:
            s = self._read()
            rows = s.posts
            if status:
                rows = [p for p in rows if p.status == status]
            return sorted(rows, key=lambda r: r.created_at, reverse=True)

    async def save_account(self, platform: str, access_token: str, refresh_token: Optional[str]) -> None:
        def _fn(s: State):
            s.accounts[platform] = {"access_token": access_token, "refresh_token": refresh_token}
            s.profile.onboarding_done["connect_account"] = True
        await self.edit(_fn)

    async def get_access_token(self, platform: str) -> Optional[str]:
        async with self.lock:
            s = self._read()
            acc = s.accounts.get(platform)
            return acc.get("access_token") if acc else None

    async def bump_usage(self) -> Tuple[str, int, int]:
        def _fn(s: State):
            yyyymm = datetime.now(timezone.utc).strftime("%Y%m")
            cur = s.profile.usage.get(yyyymm, 0) + 1
            s.profile.usage[yyyymm] = cur
            limit = ENTITLEMENTS[s.profile.plan]["max_scheduled_per_month"]
            return (yyyymm, cur, limit)
        return await self.edit(_fn)

    async def get_profile(self) -> UserProfile:
        async with self.lock:
            return self._read().profile

    async def set_plan(self, plan: str) -> None:
        def _fn(s: State):
            s.profile.plan = plan
        await self.edit(_fn)

    async def add_feedback(self, user: Optional[str], message: str, meta: Optional[Dict[str, Any]]) -> FeedbackRecord:
        def _fn(s: State):
            rec = FeedbackRecord(id=s.next_feedback_id, user=user, message=message, meta=meta)
            s.next_feedback_id += 1
            s.feedback.append(rec)
            return rec
        return await self.edit(_fn)

    async def list_feedback(self) -> List[FeedbackRecord]:
        async with self.lock:
            return self._read().feedback[::-1]

    async def add_nps(self, score: int, comment: Optional[str]) -> NPSRecord:
        def _fn(s: State):
            rec = NPSRecord(id=s.next_nps_id, score=score, comment=comment)
            s.next_nps_id += 1
            s.nps.append(rec)
            return rec
        return await self.edit(_fn)

    async def ensure_referral(self) -> Referral:
        def _fn(s: State):
            if s.profile.referral:
                return s.profile.referral
            code = secrets.token_urlsafe(6)
            s.profile.referral = Referral(code=code)
            return s.profile.referral
        return await self.edit(_fn)

    async def use_referral(self, code: str) -> bool:
        def _fn(s: State):
            ref = s.profile.referral
            if ref and ref.code == code:
                ref.uses += 1
                return True
            return False
        return await self.edit(_fn)

    async def add_lead(self, name: Optional[str], email: str, message: Optional[str]) -> LeadRecord:
        def _fn(s: State):
            rec = LeadRecord(id=s.next_lead_id, name=name, email=email, message=message)
            s.next_lead_id += 1
            s.leads.append(rec)
            return rec
        return await self.edit(_fn)

    async def upsert_flag(self, key: str, enabled: bool) -> Dict[str, bool]:
        def _fn(s: State):
            s.profile.flags[key] = bool(enabled)
            return s.profile.flags
        return await self.edit(_fn)

    async def add_custom_template(self, t: Dict[str, Any]) -> None:
        def _fn(s: State):
            s.custom_templates = [x for x in s.custom_templates if x.get("id") != t.get("id")]
            s.custom_templates.append(t)
        await self.edit(_fn)

    async def list_custom_templates(self) -> List[Dict[str, Any]]:
        async with self.lock:
            return self._read().custom_templates

store = Store(DATA_FILE)

# ----- helpers: hashtags/score + simple generator -----
def _hashtag_suggest(text: str, limit: int = 5) -> List[str]:
    words = re.findall(r"[A-Za-z][A-Za-z0-9']{3,}", text.lower())
    stop = {"this", "that", "with", "from", "your", "about", "into", "have"}
    freq: Dict[str, int] = {}
    for w in words:
        if w in stop:
            continue
        freq[w] = freq.get(w, 0) + 1
    ranked = sorted(freq.items(), key=lambda kv: (-kv[1], kv[0]))
    return [f"#{w}" for w, _ in ranked[:limit]]

def _score(text: str) -> float:
    length = len(text); score = 0.5
    if 120 <= length <= 240: score += 0.3
    if re.search(r"\b(let's|try|do|build|learn|start|join|grab)\b", text.lower()): score += 0.15
    if re.search(r"[ðŸš€âœ¨ðŸ”¥âœ…ðŸŽ¯ðŸ’¡]", text): score += 0.05
    return round(min(score, 1.0), 2)

def generate_variants(topic: str, tone: str, count: int) -> List[Dict[str, Any]]:
    out: List[Dict[str, Any]] = []
    for i in range(count):
        content = f"{topic.strip()} â€” {tone} take #{i+1}. Action: reply with your biggest blocker."
        out.append({"content": content, "hashtags": _hashtag_suggest(content), "score": _score(content), "rationale": "length_tune|imperative|emoji_opt", "cost_gbp": 0.0})
    return out

# Engagement helper
def generate_replies(context: str, mood: str = "supportive", count: int = 3) -> List[str]:
    # why: quick comment ideas to boost reach without LLM dependency
    starters = {
        "supportive": ["Love this insight!", "Totally agree.", "Brilliant point."],
        "curious": ["Curiousâ€”", "Interestingâ€”", "Quick question:"],
        "challenging": ["Counterpoint:", "Have you considered", "Pushback:"],
    }.get(mood, ["Thanks for sharing!"])
    outs = []
    for i in range(count):
        s = starters[i % len(starters)]
        outs.append(f"{s} {context.strip()[:120]} Whatâ€™s the one thing youâ€™d do next?")
    return outs

# ----- publisher (demo-safe) -----
def publish_stub(platform: str, content: str, token: Optional[str]) -> Tuple[bool, Optional[str], Optional[str]]:
    if not token:
        return False, None, "missing_access_token"
    ext_id = f"{platform}_{abs(hash(content)) % 10_000_000}"
    return True, ext_id, None

# ----- templates (for CX speed) -----
TEMPLATES: List[Dict[str, Any]] = [
    {"id": "lead_gen_1", "purpose": "lead_gen", "title": "Lead magnet", "template": "Struggling with {pain}? Grab our free {lead_magnet} to {benefit}. {cta}"},
    {"id": "announcement_1", "purpose": "announcement", "title": "New feature", "template": "Weâ€™ve launched {feature}! It helps you {benefit}. Try it today â†’ {cta}"},
    {"id": "educational_1", "purpose": "educational", "title": "Quick how-to", "template": "3 fast steps to {goal}: 1){step1} 2){step2} 3){step3}. Save this. {cta}"},
]

def all_templates() -> List[Dict[str, Any]]:
    # why: merge built-ins and user templates
    return TEMPLATES + asyncio.run(store.list_custom_templates())

def render_template(tpl_id: str, variables: Dict[str, str]) -> str:
    for t in TEMPLATES:
        if t["id"] == tpl_id:
            try:
                return t["template"].format(**variables)
            except KeyError as e:
                raise HTTPException(status_code=400, detail=f"Missing variable: {str(e).strip(\"'\")}")
    for t in asyncio.run(store.list_custom_templates()):
        if t.get("id") == tpl_id:
            try:
                return t["template"].format(**variables)
            except KeyError as e:
                raise HTTPException(status_code=400, detail=f"Missing variable: {str(e).strip(\"'\")}")
    raise HTTPException(status_code=404, detail="Template not found")

# ----- best-time helpers -----
def _best_time_from_posts(posts: List[PostRecord]) -> List[Tuple[int,int]]:
    buckets: Dict[Tuple[int,int], int] = {}
    for p in posts:
        if p.status != "published" or not p.scheduled_time:
            continue
        try:
            dt = datetime.fromisoformat(p.scheduled_time)
        except Exception:
            continue
        key = (dt.weekday(), dt.hour)
        buckets[key] = buckets.get(key, 0) + 1
    ranked = sorted(buckets.items(), key=lambda kv: (-kv[1], kv[0][0], kv[0][1]))
    return [k for k,_ in ranked]

def _best_time_defaults() -> List[Tuple[int,int]]:
    # office hours + early evening, Tueâ€“Thu bias
    return [(1,11),(2,11),(3,11),(4,11),(2,18),(3,18),(4,18)]

def _format_slots(slots: List[Tuple[int,int]], limit: int = 3) -> List[Dict[str, Any]]:
    names = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"]
    return [{"dow": names[d], "hour_24": h, "local_label": f"{names[d]} {h:02d}:00"} for d,h in slots[:limit]]

def _next_occurrence_utc(dow: int, hour: int) -> datetime:
    now = datetime.now(timezone.utc)
    days_ahead = (dow - now.weekday()) % 7
    candidate = (now + timedelta(days=days_ahead)).replace(hour=hour, minute=0, second=0, microsecond=0)
    if candidate <= now:
        candidate += timedelta(days=7)
    return candidate

# ----- API schemas -----
Platform = Literal["x", "linkedin"]

class GenerateRequest(BaseModel):
    topic: str = Field(..., min_length=2, max_length=500)
    tone: str = Field(default="helpful")
    count: int = Field(default=3, ge=1, le=10)
    provider: Optional[str] = Field(default=None)

class DraftOut(BaseModel):
    content: str
    hashtags: List[str]
    score: float
    rationale: str
    cost_gbp: Optional[float] = None

class CreatePostRequest(BaseModel):
    platform: Platform
    content: str = Field(..., min_length=1, max_length=4000)
    scheduled_time: Optional[datetime] = None

class PostOut(BaseModel):
    id: int
    platform: Platform
    content: str
    status: str
    scheduled_time: Optional[str]
    external_id: Optional[str]
    error: Optional[str]
    created_at: str
    updated_at: str

class ManualAuthRequest(BaseModel):
    platform: Platform
    access_token: str
    refresh_token: Optional[str] = None

class RenderRequest(BaseModel):
    template_id: str
    variables: Dict[str, str]

class NPSIn(BaseModel):
    score: int = Field(..., ge=0, le=10)
    comment: Optional[str] = None

class LeadIn(BaseModel):
    name: Optional[str] = None
    email: str
    message: Optional[str] = None

class EventIn(BaseModel):
    type: str
    meta: Optional[Dict[str, Any]] = None

class BulkFromTemplateIn(BaseModel):
    template_id: str
    variables: Dict[str, Any]  # values can be str or list[str]
    count: int = Field(default=10, ge=1, le=100)
    platform: Platform = "x"
    start_from_next_slot: bool = True

class AdminTemplateIn(BaseModel):
    id: str
    purpose: str
    title: str
    template: str

class SmartReplyIn(BaseModel):
    context: str
    mood: str = "supportive"
    count: int = Field(default=3, ge=1, le=10)

# ----- app -----
app = FastAPI(title="Smart Flow Systems â€” Social AI", version="0.7.0")
_scheduler_task: Optional[asyncio.Task] = None

@app.on_event("startup")
async def _start():
    global _scheduler_task
    if RUN_SCHED:
        _scheduler_task = asyncio.create_task(_scheduler_loop())

@app.on_event("shutdown")
async def _stop():
    if RUN_SCHED and _scheduler_task:
        _scheduler_task.cancel()

# ----- health/me/plans/billing -----
@app.get("/healthz")
async def healthz():
    prof = await store.get_profile()
    return {"ok": True, "brand": "Smart Flow Systems", "env": APP_ENV, "scheduler": RUN_SCHED, "plan": prof.plan}

@app.get("/me")
async def me():
    prof = await store.get_profile()
    yyyymm = datetime.now(timezone.utc).strftime("%Y%m")
    usage = prof.usage.get(yyyymm, 0)
    limit = ENTITLEMENTS[prof.plan]["max_scheduled_per_month"]
    return {"plan": prof.plan, "usage_this_month": usage, "limit": limit, "entitlements": ENTITLEMENTS[prof.plan],
            "onboarding": prof.onboarding_done, "referral": asdict(prof.referral) if prof.referral else None, "flags": prof.flags}

@app.get("/plans")
async def plans():
    return {"currency": "GBP", "plans": ENTITLEMENTS}

@app.post("/billing/checkout")
async def billing_checkout(target_plan: str = "pro"):
    if target_plan not in ENTITLEMENTS:
        raise HTTPException(status_code=400, detail="unknown_plan")
    await store.set_plan(target_plan)
    return {"ok": True, "plan": target_plan, "url": "#"}

# ----- core actions -----
@app.post("/auth/manual")
async def manual_auth(req: ManualAuthRequest):
    await store.save_account(req.platform, req.access_token, req.refresh_token)
    return {"ok": True, "platform": req.platform}

@app.post("/generate", response_model=List[DraftOut])
async def generate(req: GenerateRequest):
    prof = await store.get_profile()
    if (req.provider or LLM_PROVIDER) == "openai" and not ENTITLEMENTS[prof.plan]["allow_openai"]:
        raise HTTPException(status_code=402, detail="upgrade_required_for_openai")
    drafts = generate_variants(req.topic, req.tone, req.count)
    # onboarding nudge
    await store.edit(lambda s: s.profile.onboarding_done.__setitem__("generate_draft", True) or None)
    return [DraftOut(**d) for d in drafts]

@app.post("/posts", response_model=PostOut)
async def create_or_schedule(req: CreatePostRequest):
    when = req.scheduled_time or datetime.now(timezone.utc) + timedelta(seconds=10)
    if when.tzinfo is None:
        when = when.replace(tzinfo=timezone.utc)
    if when < datetime.now(timezone.utc):
        raise HTTPException(status_code=400, detail="scheduled_time must be in the future")

    prof = await store.get_profile()
    yyyymm = datetime.now(timezone.utc).strftime("%Y%m")
    current = prof.usage.get(yyyymm, 0)
    limit = ENTITLEMENTS[prof.plan]["max_scheduled_per_month"]
    if current >= limit:
        raise HTTPException(status_code=402, detail="quota_exceeded_upgrade")

    rec = PostRecord(id=0, platform=req.platform, content=req.content.strip(), status="scheduled", scheduled_time=when.isoformat())
    saved = await store.add_post(rec)
    await store.bump_usage()
    await store.edit(lambda s: s.profile.onboarding_done.__setitem__("schedule_post", True) or None)
    return PostOut(**asdict(saved))

@app.get("/posts", response_model=List[PostOut])
async def list_posts(status: Optional[str] = Query(default=None)):
    rows = await store.list_posts(status=status)
    return [PostOut(**asdict(r)) for r in rows]

# ----- templates & rendering -----
@app.get("/templates")
async def list_templates(purpose: Optional[str] = None):
    built = [t for t in TEMPLATES if (purpose is None or t["purpose"] == purpose)]
    custom = [t for t in await store.list_custom_templates() if (purpose is None or t.get("purpose") == purpose)]
    return {"count": len(built)+len(custom), "templates": built + custom}

@app.post("/templates/render")
async def render_tpl(req: RenderRequest):
    text = render_template(req.template_id, req.variables)
    return {"content": text, "hashtags": _hashtag_suggest(text), "score": _score(text)}

@app.post("/admin/templates", dependencies=[])
async def add_custom_template(req: AdminTemplateIn, x_admin_token: str = Header(default="")):
    if ADMIN_TOKEN and x_admin_token != ADMIN_TOKEN:
        raise HTTPException(status_code=401, detail="unauthorised")
    await store.add_custom_template(req.model_dump())
    return {"ok": True}

# ----- best-time & bulk scheduling -----
@app.get("/best-time")
async def best_time(platform: Optional[Platform] = None, tz: str = "Europe/London"):
    posts = await store.list_posts(status="published")
    slots = _best_time_from_posts(posts) or _best_time_defaults()
    return {"platform": platform, "timezone": tz, "slots": _format_slots(slots)}

def _cycle_variants(variables: Dict[str, Any], n: int) -> List[Dict[str, str]]:
    keys = list(variables.keys())
    pools: List[List[str]] = []
    for k in keys:
        v = variables[k]
        pools.append(v if isinstance(v, list) else [str(v)])
    out: List[Dict[str, str]] = []
    for i in range(n):
        item = {}
        for idx, k in enumerate(keys):
            vals = pools[idx]
            item[k] = str(vals[i % len(vals)])
        out.append(item)
    return out

@app.post("/bulk/schedule_from_template")
async def bulk_schedule(req: BulkFromTemplateIn):
    prof = await store.get_profile()
    yyyymm = datetime.now(timezone.utc).strftime("%Y%m")
    current = prof.usage.get(yyyymm, 0)
    limit = ENTITLEMENTS[prof.plan]["max_scheduled_per_month"]
    remaining = max(0, limit - current)
    if remaining <= 0:
        raise HTTPException(status_code=402, detail="quota_exceeded_upgrade")

    count = min(req.count, remaining)
    posts = await store.list_posts(status="published")
    slots = _best_time_from_posts(posts) or _best_time_defaults()
    when_list: List[datetime] = []
    for i in range(count):
        dow, hour = slots[i % len(slots)]
        dt = _next_occurrence_utc(dow, hour)
        dt += timedelta(days=(i // len(slots)))  # stagger across weeks
        if not req.start_from_next_slot:
            dt = datetime.now(timezone.utc) + timedelta(minutes=10 + i)
        when_list.append(dt)

    var_sets = _cycle_variants(req.variables, count)
    created: List[Dict[str, Any]] = []
    for i in range(count):
        text = render_template(req.template_id, var_sets[i])
        payload = CreatePostRequest(platform=req.platform, content=text, scheduled_time=when_list[i])
        try:
            out = await create_or_schedule(payload)
            created.append(out.model_dump())
        except HTTPException as e:
            return {"created": created, "error": {"status": e.status_code, "detail": e.detail}}
    return {"created": created, "error": None}

# ----- CX: feedback/NPS/referrals/leads/events/onboarding -----
@app.post("/feedback")
async def leave_feedback(user: Optional[str] = None, message: str = "", meta: Optional[str] = None):
    rec = await store.add_feedback(user, message.strip(), {"raw": meta} if meta else None)
    return {"ok": True, "id": rec.id, "created_at": rec.created_at}

@app.get("/feedback")
async def list_feedback_api():
    rows = await store.list_feedback()
    return {"count": len(rows), "items": [asdict(r) for r in rows]}

@app.post("/nps/submit")
async def nps_submit(req: NPSIn):
    rec = await store.add_nps(req.score, req.comment)
    return {"ok": True, "id": rec.id}

@app.post("/referrals/create")
async def referrals_create():
    ref = await store.ensure_referral()
    return asdict(ref)

@app.post("/referrals/redeem")
async def referrals_redeem(code: str):
    ok = await store.use_referral(code)
    return {"ok": ok}

@app.get("/referrals/stats")
async def referrals_stats():
    prof = await store.get_profile()
    return {"referral": asdict(prof.ref