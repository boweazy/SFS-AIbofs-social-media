# path: requirements.txt
fastapi>=0.111
uvicorn[standard]>=0.30
pydantic>=2.7
openai>=1.40

# path: .replit
run = """
pkill -f gunicorn >/dev/null 2>&1 || true
python3 -m pip install -U pip >/dev/null 2>&1
python3 -m pip install -r requirements.txt >/dev/null 2>&1
uvicorn main:app --host 0.0.0.0 --port 8000 --reload
"""
language = "python3"

# path: .gitignore
__pycache__/
*.pyc
data.json
.env

# path: main.py
from __future__ import annotations

import os
import asyncio
import json
import math
import re
from dataclasses import asdict, dataclass, field
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Any, Dict, List, Literal, Optional, Tuple

from fastapi import FastAPI, HTTPException, Query
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse
from starlette.responses import FileResponse
from pydantic import BaseModel, Field

# Absolute paths (why: avoid 500 when CWD differs)
BASE_DIR = Path(__file__).resolve().parent
STATIC_DIR = BASE_DIR / "static"
DATA_FILE = BASE_DIR / "data.json"

# Env config
APP_ENV = os.getenv("APP_ENV", "dev")
RUN_SCHED = os.getenv("RUN_SCHEDULER", "true").lower() == "true"
LLM_PROVIDER = os.getenv("LLM_PROVIDER", "").lower()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
LLM_MODEL = os.getenv("LLM_MODEL", "gpt-4o-mini")
LLM_INPUT_COST_PER_1K_GBP = float(os.getenv("LLM_INPUT_COST_PER_1K_GBP", "0.002"))
LLM_OUTPUT_COST_PER_1K_GBP = float(os.getenv("LLM_OUTPUT_COST_PER_1K_GBP", "0.006"))

# ---------- Data ----------
@dataclass
class PostRecord:
    id: int
    platform: str
    content: str
    status: Literal["draft", "scheduled", "published", "failed"] = "scheduled"
    scheduled_time: Optional[str] = None
    external_id: Optional[str] = None
    error: Optional[str] = None
    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    updated_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

@dataclass
class FeedbackRecord:
    id: int
    user: Optional[str]
    message: str
    meta: Optional[Dict[str, Any]] = None
    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

@dataclass
class State:
    next_post_id: int = 1
    posts: List[PostRecord] = field(default_factory=list)
    accounts: Dict[str, Dict[str, Optional[str]]] = field(default_factory=dict)
    next_feedback_id: int = 1
    feedback: List[FeedbackRecord] = field(default_factory=list)

class Store:
    """Single-file store (why: zero-setup DB)."""
    def __init__(self, file: Path):
        self.file = file
        self.lock = asyncio.Lock()
        if not file.exists():
            self._write(State())

    def _read(self) -> State:
        raw = json.loads(self.file.read_text() or "{}")
        if not raw:
            return State()
        posts = [PostRecord(**p) for p in raw.get("posts", [])]
        fb = [FeedbackRecord(**f) for f in raw.get("feedback", [])]
        return State(
            next_post_id=raw.get("next_post_id", 1),
            posts=posts,
            accounts=raw.get("accounts", {}),
            next_feedback_id=raw.get("next_feedback_id", 1),
            feedback=fb,
        )

    def _write(self, state: State) -> None:
        payload = {
            "next_post_id": state.next_post_id,
            "posts": [asdict(p) for p in state.posts],
            "accounts": state.accounts,
            "next_feedback_id": state.next_feedback_id,
            "feedback": [asdict(f) for f in state.feedback],
        }
        self.file.write_text(json.dumps(payload, ensure_ascii=False, indent=2))

    async def add_post(self, rec: PostRecord) -> PostRecord:
        async with self.lock:
            s = self._read()
            rec.id = s.next_post_id
            s.next_post_id += 1
            s.posts.append(rec)
            self._write(s)
            return rec

    async def update_post(self, rec: PostRecord) -> None:
        async with self.lock:
            s = self._read()
            for i, p in enumerate(s.posts):
                if p.id == rec.id:
                    s.posts[i] = rec
                    break
            self._write(s)

    async def list_posts(self, status: Optional[str] = None) -> List[PostRecord]:
        async with self.lock:
            s = self._read()
            rows = s.posts
            if status:
                rows = [p for p in rows if p.status == status]
            return sorted(rows, key=lambda r: r.created_at, reverse=True)

    async def save_account(self, platform: str, access_token: str, refresh_token: Optional[str]) -> None:
        async with self.lock:
            s = self._read()
            s.accounts[platform] = {"access_token": access_token, "refresh_token": refresh_token}
            self._write(s)

    async def get_access_token(self, platform: str) -> Optional[str]:
        async with self.lock:
            s = self._read()
            acc = s.accounts.get(platform)
            return acc.get("access_token") if acc else None

    async def add_feedback(self, user: Optional[str], message: str, meta: Optional[Dict[str, Any]]) -> FeedbackRecord:
        async with self.lock:
            s = self._read()
            rec = FeedbackRecord(id=s.next_feedback_id, user=user, message=message, meta=meta)
            s.next_feedback_id += 1
            s.feedback.append(rec)
            self._write(s)
            return rec

    async def list_feedback(self) -> List[FeedbackRecord]:
        async with self.lock:
            s = self._read()
            return sorted(s.feedback, key=lambda r: r.created_at, reverse=True)

store = Store(DATA_FILE)

# ---------- Helpers ----------
def _hashtag_suggest(text: str, limit: int = 5) -> List[str]:
    words = re.findall(r"[A-Za-z][A-Za-z0-9']{3,}", text.lower())
    stop = {"this", "that", "with", "from", "your", "about", "into", "have"}
    freq: Dict[str, int] = {}
    for w in words:
        if w in stop:
            continue
        freq[w] = freq.get(w, 0) + 1
    ranked = sorted(freq.items(), key=lambda kv: (-kv[1], kv[0]))
    return [f"#{w}" for w, _ in ranked[:limit]]

def _score(text: str) -> float:
    length = len(text)
    score = 0.5
    if 120 <= length <= 240: score += 0.3
    if re.search(r"\b(let's|try|do|build|learn|start|join|grab)\b", text.lower()): score += 0.15
    if re.search(r"[🚀✨🔥✅🎯💡]", text): score += 0.05
    return round(min(score, 1.0), 2)

def _stub_variants(topic: str, tone: str, count: int) -> List[Dict[str, Any]]:
    out = []
    for i in range(count):
        content = f"{topic.strip()} — {tone} take #{i+1}. Action: reply with your biggest blocker."
        out.append({"content": content, "hashtags": _hashtag_suggest(content), "score": _score(content), "rationale": "length_tune|imperative|emoji_opt", "cost_gbp": 0.0})
    return out

def _approx_tokens(text: str) -> int:
    return max(1, math.ceil(len(text) / 4))

def _estimate_gbp(tokens_in: int, tokens_out: int) -> float:
    return round((tokens_in/1000.0)*LLM_INPUT_COST_PER_1K_GBP + (tokens_out/1000.0)*LLM_OUTPUT_COST_PER_1K_GBP, 4)

async def _openai_variants(topic: str, tone: str, count: int, model: str) -> List[Dict[str, Any]]:
    if not OPENAI_API_KEY:
        return _stub_variants(topic, tone, count)
    try:
        from openai import OpenAI
    except Exception:
        return _stub_variants(topic, tone, count)

    client = OpenAI(api_key=OPENAI_API_KEY)
    out: List[Dict[str, Any]] = []
    for _ in range(count):
        user_prompt = (
            f"Write a single concise, helpful social post about '{topic}'. "
            f"Tone: {tone}. Under ~240 chars if possible. Include a clear CTA. Avoid hashtags in the body."
        )
        pre_in = _approx_tokens(user_prompt)
        resp = client.chat.completions.create(
            model=model,
            messages=[
                {"role": "system", "content": "You write practical, on-brand social posts."},
                {"role": "user", "content": user_prompt},
            ],
            temperature=0.7,
        )
        text = (resp.choices[0].message.content or "").strip()
        usage = getattr(resp, "usage", None)
        tokens_in = int(getattr(usage, "prompt_tokens", pre_in) or pre_in) if usage else pre_in
        tokens_out = int(getattr(usage, "completion_tokens", _approx_tokens(text)) or _approx_tokens(text)) if usage else _approx_tokens(text)
        cost = _estimate_gbp(tokens_in, tokens_out)
        out.append({"content": text, "hashtags": _hashtag_suggest(text), "score": _score(text), "rationale": "llm|scored", "cost_gbp": cost})
    return out

def publish_stub(platform: str, content: str, token: Optional[str]) -> Tuple[bool, Optional[str], Optional[str]]:
    if not token: return False, None, "missing_access_token"
    ext_id = f"{platform}_{abs(hash(content)) % 10_000_000}"
    return True, ext_id, None

# Templates library
TEMPLATES: List[Dict[str, Any]] = [
    {"id": "lead_gen_1", "purpose": "lead_gen", "title": "Lead magnet", "template": "Struggling with {pain}? Grab our free {lead_magnet} to {benefit}. {cta}"},
    {"id": "announcement_1", "purpose": "announcement", "title": "New feature", "template": "We’ve launched {feature}! It helps you {benefit}. Try it today → {cta}"},
    {"id": "educational_1", "purpose": "educational", "title": "Quick how-to", "template": "3 fast steps to {goal}: 1){step1} 2){step2} 3){step3}. Save this. {cta}"},
    {"id": "event_1", "purpose": "event", "title": "Event invite", "template": "Join us on {date_local} for {event}. Learn {benefit}. Seats are limited — {cta}"},
    {"id": "testimonial_1", "purpose": "testimonial", "title": "Customer proof", "template": "\"{quote}\" — {customer}. Result: {result}. Want the same? {cta}"},
    {"id": "promo_1", "purpose": "promotion", "title": "Time-limited offer", "template": "{offer}: {percent}% off until {until_date}. Perfect for {audience}. {cta}"},
    {"id": "bts_1", "purpose": "behind_scenes", "title": "Behind the scenes", "template": "A peek behind the scenes: {process}. Built with ❤️ to {benefit}. {cta}"},
]

def render_template(tpl_id: str, variables: Dict[str, str]) -> str:
    for t in TEMPLATES:
        if t["id"] == tpl_id:
            try:
                return t["template"].format(**variables)
            except KeyError as e:
                raise HTTPException(status_code=400, detail=f"Missing variable: {str(e).strip(\"'\")}")
    raise HTTPException(status_code=404, detail="Template not found")

def _best_time_from_posts(posts: List[PostRecord]) -> List[Tuple[int,int]]:
    buckets: Dict[Tuple[int,int], int] = {}
    for p in posts:
        if p.status != "published" or not p.scheduled_time: continue
        try:
            dt = datetime.fromisoformat(p.scheduled_time)
        except Exception:
            continue
        dt_local = dt  # stored UTC; label only
        key = (dt_local.weekday(), dt_local.hour)
        buckets[key] = buckets.get(key, 0) + 1
    ranked = sorted(buckets.items(), key=lambda kv: (-kv[1], kv[0][0], kv[0][1]))
    return [k for k,_ in ranked]

def _best_time_defaults() -> List[Tuple[int,int]]:
    return [(1,11),(2,11),(3,11),(4,11),(2,18),(3,18),(4,18)]

def _format_slots(slots: List[Tuple[int,int]], limit: int = 3) -> List[Dict[str, Any]]:
    names = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"]
    return [{"dow": names[d], "hour_24": h, "local_label": f"{names[d]} {h:02d}:00"} for d,h in slots[:limit]]

# ---------- Schemas ----------
Platform = Literal["x","linkedin"]

class GenerateRequest(BaseModel):
    topic: str = Field(..., min_length=2, max_length=500)
    tone: str = Field(default="helpful")
    count: int = Field(default=3, ge=1, le=10)
    provider: Optional[str] = Field(default=None)
    model: Optional[str] = Field(default=None)

class DraftOut(BaseModel):
    content: str; hashtags: List[str]; score: float; rationale: str; cost_gbp: Optional[float] = None

class CreatePostRequest(BaseModel):
    platform: Platform
    content: str = Field(..., min_length=1, max_length=4000)
    scheduled_time: Optional[datetime] = None

class PostOut(BaseModel):
    id: int; platform: Platform; content: str; status: str
    scheduled_time: Optional[str]; external_id: Optional[str]; error: Optional[str]
    created_at: str; updated_at: str

class ManualAuthRequest(BaseModel):
    platform: Platform; access_token: str; refresh_token: Optional[str] = None

class RenderRequest(BaseModel):
    template_id: str
    variables: Dict[str,str]

class AgentRequest(BaseModel):
    question: str
    goal: Optional[str] = None
    platform: Optional[Platform] = None

class FeedbackIn(BaseModel):
    user: Optional[str] = None
    message: str
    meta: Optional[Dict[str,Any]] = None

# ---------- App ----------
app = FastAPI(title="Smart Flow Systems — Social AI", version="0.4.0")
_scheduler_task: Optional[asyncio.Task] = None

@app.on_event("startup")
async def _start():
    global _scheduler_task
    if RUN_SCHED:
        _scheduler_task = asyncio.create_task(_scheduler_loop())

@app.on_event("shutdown")
async def _stop():
    if RUN_SCHED and _scheduler_task:
        _scheduler_task.cancel()

# Health & auth
@app.get("/healthz")
async def healthz():
    return {"ok": True, "brand": "Smart Flow Systems", "env": APP_ENV, "scheduler": RUN_SCHED, "llm": {"provider": LLM_PROVIDER or "stub", "model": LLM_MODEL}}

@app.post("/auth/manual")
async def manual_auth(req: ManualAuthRequest):
    await store.save_account(req.platform, req.access_token, req.refresh_token)
    return {"ok": True, "platform": req.platform}

# Compose
@app.post("/generate", response_model=List[DraftOut])
async def generate(req: GenerateRequest):
    use_openai = (req.provider or LLM_PROVIDER) == "openai"
    model = req.model or LLM_MODEL
    drafts = await _openai_variants(req.topic, req.tone, req.count, model) if use_openai else _stub_variants(req.topic, req.tone, req.count)
    return [DraftOut(**d) for d in drafts]

@app.post("/posts", response_model=PostOut)
async def create_or_schedule(req: CreatePostRequest):
    when = req.scheduled_time or datetime.now(timezone.utc) + timedelta(seconds=10)
    if when.tzinfo is None: when = when.replace(tzinfo=timezone.utc)
    if when < datetime.now(timezone.utc): raise HTTPException(status_code=400, detail="scheduled_time must be in the future")
    rec = PostRecord(id=0, platform=req.platform, content=req.content.strip(), status="scheduled", scheduled_time=when.isoformat())
    saved = await store.add_post(rec)
    return PostOut(**asdict(saved))

@app.get("/posts", response_model=List[PostOut])
async def list_posts(status: Optional[str] = Query(default=None)):
    rows = await store.list_posts(status=status)
    return [PostOut(**asdict(r)) for r in rows]

# Premium scaffolding
@app.get("/templates")
async def list_templates(purpose: Optional[str] = None):
    rows = [t for t in TEMPLATES if (purpose is None or t["purpose"] == purpose)]
    return {"count": len(rows), "templates": rows}

@app.post("/templates/render")
async def render_tpl(req: RenderRequest):
    text = render_template(req.template_id, req.variables)
    return {"content": text, "hashtags": _hashtag_suggest(text), "score": _score(text)}

@app.post("/agent/ask")
async def agent_ask(req: AgentRequest):
    goal = (req.goal or "").lower()
    mapping = {"leads": ["lead_gen_1","testimonial_1"], "launch": ["announcement_1","promo_1"], "event": ["event_1","lead_gen_1"], "education": ["educational_1","bts_1"]}
    candidates = mapping.get(goal, ["educational_1","lead_gen_1"])
    tips = {"x": "Keep it punchy, ~240 chars. Hook → benefit → CTA.", "linkedin": "Lead with outcome. Line breaks + clear CTA."}
    answer = f"Goal='{goal or 'general'}'. For {req.platform or 'platforms'}: {tips.get(req.platform or 'x', tips['x'])}"
    return {"answer": answer, "suggested_templates": [t for t in TEMPLATES if t["id"] in candidates]}

@app.get("/best-time")
async def best_time(platform: Optional[Platform] = None, tz: str = "Europe/London"):
    posts = await store.list_posts(status="published")
    slots = _best_time_from_posts(posts) or _best_time_defaults()
    return {"platform": platform, "timezone": tz, "slots": _format_slots(slots)}

@app.post("/feedback")
async def leave_feedback(req: FeedbackIn):
    rec = await store.add_feedback(req.user, req.message.strip(), req.meta)
    return {"ok": True, "id": rec.id, "created_at": rec.created_at}

@app.get("/feedback")
async def list_feedback():
    rows = await store.list_feedback()
    return {"count": len(rows), "items": [asdict(r) for r in rows]}

@app.get("/pricing")
async def pricing():
    tiers = [
        {"id":"free","name":"Free","gbp_per_month":0,"limits":{"brands":1,"accounts":2,"scheduled_posts":30},"features":["Basic templates","Default best-time","Feedback"]},
        {"id":"starter","name":"Starter","gbp_per_month":9,"limits":{"brands":3,"accounts":6},"features":["Goal templates + render","Best-time from history","Email export (soon)"]},
        {"id":"pro","name":"Pro","gbp_per_month":29,"limits":{"brands":10,"accounts":15},"features":["OpenAI drafts (quota)","Hashtag intel","A/B copy","Calendar CSV","Agent"]},
        {"id":"business","name":"Business","gbp_per_month":79,"limits":{"brands":"unlimited","accounts":"unlimited"},"features":["Approvals","Advocacy packs","Link in bio","Advanced analytics"]},
    ]
    return {"currency":"GBP","tiers":tiers}

# Scheduler
async def _scheduler_loop():
    while True:
        try:
            await _publish_due()
        except Exception as e:
            print("scheduler error:", e)
        await asyncio.sleep(5)

async def _publish_due():
    now = datetime.now(timezone.utc)
    rows = await store.list_posts(status="scheduled")
    for rec in rows:
        due = datetime.fromisoformat(rec.scheduled_time) if rec.scheduled_time else now
        if due <= now:
            token = await store.get_access_token(rec.platform)
            ok, ext_id, err = publish_stub(rec.platform, rec.content, token)
            rec.status = "published" if ok else "failed"
            rec.external_id = ext_id
            rec.error = err
            rec.updated_at = datetime.now(timezone.utc).isoformat()
            await store.update_post(rec)

# Static
if not STATIC_DIR.exists(): STATIC_DIR.mkdir(parents=True, exist_ok=True)
app.mount("/static", StaticFiles(directory=str(STATIC_DIR)), name="static")

@app.get("/")
async def index():
    index_path = STATIC_DIR / "index.html"
    if index_path.exists(): return FileResponse(str(index_path))
    html = f"""<!doctype html><html><body style="font-family:system-ui;padding:24px;color:#eee;background:#111">
      <h1>Smart Flow Systems</h1>
      <p>UI missing at: <code>{index_path}</code>. Health: <a href="/healthz">/healthz</a></p>
    </body></html>"""
    return HTMLResponse(html, status_code=200)

# path: static/index.html
<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Smart Flow Systems — Social AI</title>
  <link rel="stylesheet" href="/static/style.css" />
</head>
<body>
  <header class="sfs-header">
    <div class="brand">
      <span class="logo" aria-hidden="true">★</span>
      <h1>Smart Flow Systems</h1>
    </div>
    <div class="auth">
      <select id="platform" aria-label="Platform">
        <option value="x">X (Twitter)</option>
        <option value="linkedin">LinkedIn</option>
      </select>
      <input id="token" placeholder="Access token (stub)" aria-label="Access token" />
      <button id="saveToken">Save token</button>
    </div>
  </header>

  <nav class="tabs">
    <button data-tab="compose" class="active">Compose</button>
    <button data-tab="templates">Templates</button>
    <button data-tab="agent">Agent</button>
    <button data-tab="besttime">Best Time</button>
    <button data-tab="feedback">Feedback</button>
    <button data-tab="pricing">Pricing</button>
  </nav>

  <main class="grid">
    <section class="card tab" id="tab-compose" style="display:block">
      <h2>Compose</h2>
      <form id="genForm">
        <label>Topic
          <input id="topic" required placeholder="e.g., AI tips for creators" />
        </label>
        <div class="row">
          <label>Tone
            <select id="tone">
              <option>helpful</option><option>concise</option><option>friendly</option><option>bold</option>
            </select>
          </label>
          <label>How many
            <input id="count" type="number" min="1" max="10" value="3" />
          </label>
          <label class="inline">
            <input id="useOpenAI" type="checkbox" />
            <span>Use OpenAI</span>
          </label>
          <label>Model
            <input id="model" value="gpt-4o-mini" />
          </label>
        </div>
        <button type="submit">Create drafts</button>
      </form>
      <div id="costNote" class="muted"></div>
      <div id="drafts" class="drafts"></div>

      <h3>Schedule</h3>
      <form id="scheduleForm">
        <div class="row">
          <label>Platform
            <select id="schedPlatform">
              <option value="x">X (Twitter)</option>
              <option value="linkedin">LinkedIn</option>
            </select>
          </label>
          <label>When (Europe/London, optional)
            <input id="when" type="datetime-local" />
          </label>
        </div>
        <label>Content
          <textarea id="content" rows="6" placeholder="Write or click a draft →"></textarea>
        </label>
        <button type="submit">Schedule</button>
      </form>

      <h3>Posts</h3>
      <div class="table-wrap">
        <table>
          <thead><tr><th>ID</th><th>Platform</th><th>Status</th><th>Scheduled</th><th>External</th><th>Error</th></tr></thead>
          <tbody id="postsBody"></tbody>
        </table>
      </div>
    </section>

    <section class="card tab" id="tab-templates">
      <h2>Templates</h2>
      <div class="row">
        <label>Filter by purpose
          <select id="tplPurpose">
            <option value="">All</option>
            <option value="lead_gen">Lead gen</option>
            <option value="announcement">Announcement</option>
            <option value="educational">Educational</option>
            <option value="event">Event</option>
            <option value="testimonial">Testimonial</option>
            <option value="promotion">Promotion</option>
            <option value="behind_scenes">Behind the scenes</option>
          </select>
        </label>
        <button id="loadTemplates">Load</button>
      </div>
      <div id="tplList" class="drafts"></div>

      <h3>Render</h3>
      <form id="renderForm">
        <label>Template ID
          <input id="tplId" placeholder="e.g., lead_gen_1" />
        </label>
        <label>Variables (JSON)
          <textarea id="tplVars" rows="5" placeholder='{"pain":"X","lead_magnet":"guide","benefit":"do Y","cta":"Get it here"}'></textarea>
        </label>
        <button type="submit">Render</button>
      </form>
      <div id="renderOut"></div>
    </section>

    <section class="card tab" id="tab-agent">
      <h2>Agent</h2>
      <form id="agentForm">
        <label>Goal
          <select id="agentGoal">
            <option value="">General</option>
            <option value="leads">Leads</option>
            <option value="launch">Launch</option>
            <option value="event">Event</option>
            <option value="education">Education</option>
          </select>
        </label>
        <label>Platform
          <select id="agentPlatform">
            <option value="x">X</option><option value="linkedin">LinkedIn</option>
          </select>
        </label>
        <label>Question
          <input id="agentQ" placeholder="What should I post today?" />
        </label>
        <button type="submit">Ask</button>
      </form>
      <div id="agentOut"></div>
    </section>

    <section class="card tab" id="tab-besttime">
      <h2>Best Time</h2>
      <button id="loadBestTime">Suggest Slots</button>
      <ul id="bestSlots"></ul>
      <div class="muted">Learns from your published posts; uses smart defaults until it has data.</div>
    </section>

    <section class="card tab" id="tab-feedback">
      <h2>Feedback</h2>
      <form id="fbForm">
        <label>Your name (optional)
          <input id="fbUser" />
        </label>
        <label>Message
          <textarea id="fbMsg" rows="4" placeholder="Tell us what would help you win…"></textarea>
        </label>
        <button type="submit">Send</button>
      </form>
      <h3>Latest</h3>
      <ul id="fbList"></ul>
    </section>

    <section class="card tab" id="tab-pricing">
      <h2>Pricing (GBP)</h2>
      <div id="pricing"></div>
    </section>
  </main>

  <footer class="sfs-footer">
    <span>© <span id="year"></span> Smart Flow Systems</span>
  </footer>

  <script src="/static/app.js"></script>
</body>
</html>

# path: static/style.css
:root{
  --bg:#0a0a0a; --bg2:#1a120b; --panel:#111;
  --gold:#d4af37; --gold-soft:#c9a227;
  --text:#e9e3d0; --muted:#a08f75;
  --border:rgba(212,175,55,.35); --ring:rgba(212,175,55,.6);
}
*{box-sizing:border-box} html,body{height:100%}
body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
  background:radial-gradient(1200px 800px at 20% -10%,#20160e 0%,var(--bg) 60%),linear-gradient(180deg,var(--bg2),var(--bg));color:var(--text)}
.sfs-header,.sfs-footer{border-bottom:1px solid var(--border);background:linear-gradient(180deg,#1b130c,#0a0a0a);
  padding:12px 18px;display:flex;align-items:center;justify-content:space-between;position:sticky;top:0;z-index:10;box-shadow:0 2px 12px rgba(0,0,0,.3)}
.sfs-footer{position:static;border-top:1px solid var(--border);border-bottom:none;margin-top:24px;background:linear-gradient(180deg,#0a0a0a,#0a0a0a);color:var(--muted);text-align:center;justify-content:center}
.brand{display:flex;align-items:center;gap:10px}.logo{color:var(--gold);text-shadow:0 0 12px rgba(212,175,55,.7)}
h1{margin:0;font-size:20px;background:linear-gradient(92deg,var(--gold),#ffec99,var(--gold));-webkit-background-clip:text;background-clip:text;color:transparent;text-shadow:0 0 18px rgba(212,175,55,.2)}
.auth{display:flex;gap:8px;align-items:center}.auth input,.auth select{background:#0e0e0e;color:var(--text);border:1px solid var(--border);padding:8px 10px;border-radius:8px}
.auth button,button{background:linear-gradient(180deg,#1a130b,#0e0e0e);color:var(--text);border:1px solid var(--gold-soft);border-radius:12px;padding:10px 14px;cursor:pointer;font-weight:700;letter-spacing:.3px;transition:transform .06s ease,box-shadow .2s ease,border-color .2s ease;box-shadow:0 0 12px rgba(212,175,55,.15)}
button:hover{border-color:var(--gold);box-shadow:0 0 18px rgba(212,175,55,.25)}button:active{transform:translateY(1px)}
.grid{display:grid;gap:16px;padding:18px;grid-template-columns:repeat(auto-fit,minmax(320px,1fr))}
.card{background:linear-gradient(180deg,#0f0c09 0%,#0b0b0b 100%);border:1px solid var(--border);border-radius:16px;padding:16px;box-shadow:inset 0 0 0 1px rgba(255,255,255,.03),0 10px 30px rgba(0,0,0,.35)}
h2,h3{margin:8px 0 8px}.muted{color:var(--muted);font-size:12px;margin-top:6px}
label{display:grid;gap:6px;margin:10px 0;color:var(--muted)}
input,select,textarea{background:#0e0e0e;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:10px 12px;outline:none;transition:box-shadow .2s,border-color .2s}
input:focus,select:focus,textarea:focus{border-color:var(--gold-soft);box-shadow:0 0 0 3px var(--ring)}
.table-wrap{overflow:auto;border:1px solid var(--border);border-radius:12px}
table{width:100%;border-collapse:collapse;font-size:14px} th,td{padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.06)} th{text-align:left;color:var(--muted)}
.drafts{display:grid;gap:10px}.draft{border:1px solid var(--border);border-radius:12px;padding:12px;background:#0d0b09}
.draft .meta{color:var(--muted);font-size:12px;display:flex;gap:10px;align-items:center;margin-top:6px}
.tag{border:1px solid var(--gold-soft);border-radius:999px;padding:2px 8px;font-size:12px;color:#ffe7a1}
.tabs{display:flex;gap:8px;padding:8px 18px;border-bottom:1px solid var(--border);background:#0b0b0b;position:sticky;top:56px;z-index:5}
.tabs button{padding:8px 12px;border-radius:10px;border:1px solid var(--border)}
.tabs button.active{border-color:var(--gold);box-shadow:0 0 12px rgba(212,175,55,.2)}

# path: static/app.js
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => Array.from(document.querySelectorAll(sel));
const el = (tag, cls) => { const n=document.createElement(tag); if(cls) n.className=cls; return n; };

const postsBody = $("#postsBody");
const draftsDiv = $("#drafts");
const costNote = $("#costNote");
const yearSpan = $("#year"); if (yearSpan) yearSpan.textContent = new Date().getFullYear();

const fmtDateUK = (iso) => iso ? new Date(iso).toLocaleString("en-GB", { timeZone:"Europe/London", year:"numeric", month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit", hour12:false }) : "";

function switchTab(name){
  $$(".tabs button").forEach(b=>b.classList.toggle("active", b.dataset.tab===name));
  $$(".tab").forEach(d=>d.style.display = d.id === `tab-${name}` ? "block" : "none");
}
$$(".tabs button").forEach(b=>b.addEventListener("click", ()=>switchTab(b.dataset.tab)));

$("#saveToken").addEventListener("click", async () => {
  const platform = $("#platform").value;
  const token = $("#token").value.trim();
  if (!token) return alert("Enter a token (stub)");
  const res = await fetch("/auth/manual", { method:"POST", headers:{ "content-type":"application/json" }, body: JSON.stringify({ platform, access_token: token }) });
  alert(res.ok ? "Token saved" : "Failed to save token");
});

$("#genForm").addEventListener("submit", async (e) => {
  e.preventDefault();
  draftsDiv.textContent = "Generating…";
  costNote.textContent = "";
  const topic = $("#topic").value.trim();
  const tone = $("#tone").value;
  const count = +($("#count").value || 3);
  const body = { topic, tone, count };
  if ($("#useOpenAI").checked) { body.provider = "openai"; body.model = $("#model").value.trim(); }
  const res = await fetch("/generate", { method:"POST", headers:{ "content-type":"application/json" }, body: JSON.stringify(body) });
  const drafts = await res.json();
  draftsDiv.innerHTML = "";
  let total = 0;
  drafts.forEach((d) => {
    const card = el("div","draft");
    const body = el("div"); body.textContent = d.content;
    const meta = el("div","meta");
    const score = el("span"); score.textContent = `Score: ${d.score}`; meta.appendChild(score);
    (d.hashtags||[]).forEach(t=>{ const tag=el("span","tag"); tag.textContent=t; meta.appendChild(tag); });
    const useBtn = el("button"); useBtn.textContent = "Use this";
    useBtn.addEventListener("click", () => {
      $("#content").value = d.content + (d.hashtags?.length ? "\n\n" + d.hashtags.join(" ") : "");
      $("#schedPlatform").value = $("#platform").value;
      switchTab("compose");
      window.scrollTo({ top: document.body.scrollHeight, behavior: "smooth" });
    });
    card.append(body, meta, useBtn); draftsDiv.appendChild(card);
    if (d.cost_gbp) total += Number(d.cost_gbp);
  });
  if (total > 0) costNote.textContent = `Estimated cost: £${total.toFixed(4)} (configurable).`;
});

$("#scheduleForm").addEventListener("submit", async (e) => {
  e.preventDefault();
  const platform = $("#schedPlatform").value;
  const content = $("#content").value.trim();
  const whenRaw = $("#when").value;
  let scheduled_time = null;
  if (whenRaw) {
    const dtLocal = new Date(whenRaw);
    scheduled_time = new Date(dtLocal.getTime() - dtLocal.getTimezoneOffset()*60000).toISOString();
  }
  const res = await fetch("/posts", { method:"POST", headers:{ "content-type":"application/json" }, body: JSON.stringify({ platform, content, scheduled_time }) });
  if (!res.ok) { const err = await res.json(); return alert(err.detail || "Failed to schedule"); }
  $("#content").value=""; $("#when").value=""; refreshPosts();
});

async function refreshPosts(){
  const res = await fetch("/posts");
  const rows = await res.json();
  postsBody.innerHTML = "";
  rows.forEach(r=>{
    const tr = el("tr");
    const td = (t)=>{ const d=el("td"); d.textContent=t; return d; };
    tr.append(td(r.id), td(r.platform), td(r.status), td(r.scheduled_time ? fmtDateUK(r.scheduled_time) : ""), td(r.external_id || ""), td(r.error || ""));
    postsBody.appendChild(tr);
  });
}
setInterval(refreshPosts, 4000); refreshPosts();

$("#loadTemplates").addEventListener("click", async ()=>{
  const purpose = $("#tplPurpose").value;
  const res = await fetch(`/templates${purpose?`?purpose=${encodeURIComponent(purpose)}`:""}`);
  const data = await res.json();
  const list = $("#tplList"); list.innerHTML = "";
  data.templates.forEach(t=>{
    const card = el("div","draft");
    const title = el("div"); title.textContent = `${t.id} — ${t.title} (${t.purpose})`;
    const meta = el("div","meta"); meta.textContent = t.template;
    const useBtn = el("button"); useBtn.textContent = "Use ID";
    useBtn.addEventListener("click", ()=>{ $("#tplId").value = t.id; switchTab("templates"); });
    card.append(title, meta, useBtn); list.appendChild(card);
  });
});

$("#renderForm").addEventListener("submit", async (e)=>{
  e.preventDefault();
  const id = $("#tplId").value.trim();
  let vars;
  try { vars = JSON.parse($("#tplVars").value || "{}"); } catch { return alert("Variables must be valid JSON"); }
  const res = await fetch("/templates/render", { method:"POST", headers:{ "content-type":"application/json" }, body: JSON.stringify({ template_id:id, variables:vars }) });
  if (!res.ok) { const err=await res.json(); return alert(err.detail || "Render failed"); }
  const out = await res.json();
  $("#renderOut").innerHTML = "";
  const card = el("div","draft");
  const body = el("div"); body.textContent = out.content;
  const meta = el("div","meta"); meta.textContent = `Score ${out.score} • ${out.hashtags.join(" ")}`;
  const useBtn = el("button"); useBtn.textContent = "Send to Compose";
  useBtn.addEventListener("click", ()=>{ $("#content").value = out.content + (out.hashtags?.length ? "\n\n"+out.hashtags.join(" ") : ""); switchTab("compose"); });
  card.append(body, meta, useBtn); $("#renderOut").appendChild(card);
});

$("#agentForm").addEventListener("submit", async (e)=>{
  e.preventDefault();
  const goal = $("#agentGoal").value; const platform = $("#agentPlatform").value; const question = $("#agentQ").value.trim();
  const res = await fetch("/agent/ask", { method:"POST", headers:{ "content-type":"application/json" }, body: JSON.stringify({ goal, platform, question }) });
  const data = await res.json();
  const out = $("#agentOut"); out.innerHTML = "";
  const p = el("p"); p.textContent = data.answer; out.appendChild(p);
  data.suggested_templates.forEach(t=>{
    const li = el("div","draft"); li.textContent = `${t.id} — ${t.title}: ${t.template}`;
    out.appendChild(li);
  });
});

$("#loadBestTime").addEventListener("click", async ()=>{
  const res = await fetch("/best-time");
  const data = await res.json();
  const ul = $("#bestSlots"); ul.innerHTML = "";
  data.slots.forEach(s=>{ const li=document.createElement("li"); li.textContent = s.local_label; ul.appendChild(li); });
});

$("#fbForm").addEventListener("submit", async (e)=>{
  e.preventDefault();
  const user = $("#fbUser").value.trim() || null;
  const message = $("#fbMsg").value.trim();
  if (!message) return;
  const res = await fetch("/feedback", { method:"POST", headers:{ "content-type":"application/json" }, body: JSON.stringify({ user, message }) });
  if (res.ok) { $("#fbMsg").value=""; loadFeedback(); } else { alert("Failed to send"); }
});

async function loadFeedback(){
  const res = await fetch("/feedback"); const data = await res.json();
  const ul = $("#fbList"); ul.innerHTML = "";
  data.items.forEach(i=>{ const li=document.createElement("li"); li.textContent = `${i.created_at} — ${i.user || "anon"}: ${i.message}`; ul.appendChild(li); });
}
loadFeedback();

async function loadPricing(){
  const res = await fetch("/pricing"); const data = await res.json();
  const box = $("#pricing"); box.innerHTML = "";
  const wrap = el("div"); wrap.style.display="grid"; wrap.style.gap="10px";
  data.tiers.forEach(t=>{
    const card = el("div","draft");
    const h = el("div"); h.textContent = `${t.name} — £${t.gbp_per_month}/mo`; card.appendChild(h);
    const f = el("div","meta"); f.textContent = t.features.join(" • "); card.appendChild(f);
    wrap.appendChild(card);
  });
  box.appendChild(wrap);
}
loadPricing();