ROLE: Senior full-stack engineer. Create a brand-new Flask project on Replit for “SmartFlow Systems”.
Make/overwrite files exactly as specified, install dependencies, run the server on $PORT,
and print the live URL and next steps when done.

GOALS:
- GitHub connected (no secrets in git)
- Flask app with:
  • Landing + pricing (black & gold)
  • Stripe Checkout (monthly + one-off) + webhook
  • Plan gating (starter/flowkit/launchpack)
  • SQLAlchemy (SQLite)
  • Multi-tenant User Admin MVP (invite → accept, roles, suspend) + Admin UI
  • Email (SMTP) and **Vonage SMS** (Twilio removed)
  • Settings → Notifications (toggle Email/SMS + reminder timing)
  • Bookings + APScheduler reminders (12/24/48h before)
  • Test Booking page (no Postman needed)

========================================
1) .gitignore  (create/overwrite)
========================================
# Replit / Python project ignores
.replit
replit.nix

# Virtual environments
venv/
env/
.venv/
__pycache__/

# Python cache & build
*.pyc
*.pyo
*.pyd
*.db
*.sqlite3
*.log
*.egg-info/
dist/
build/

# Environment / secrets
.env
*.secret
*.key
secrets.json

# OS files
.DS_Store
Thumbs.db

# Node (if using frontend)
node_modules/

========================================
2) requirements.txt  (create/overwrite)
========================================
Flask>=3.0.0
gunicorn>=21.2.0
stripe>=6.0.0
python-dotenv>=1.0.1
SQLAlchemy>=2.0.30
Flask-SQLAlchemy>=3.1.1
itsdangerous>=2.2.0
requests>=2.32.0
# Google (later)
google-api-python-client>=2.124.0
google-auth>=2.31.0
google-auth-oauthlib>=1.2.0
# SMS: Vonage (Twilio removed)
vonage>=3.15.0
# Scheduler
APScheduler>=3.10.4

Install dependencies.

========================================
3) config.py  (create/overwrite)
========================================
import os

class Config:
    # Flask
    FLASK_SECRET_KEY = os.getenv("FLASK_SECRET_KEY", "fallback-secret")
    DEBUG = os.getenv("DEBUG", "False").lower() in ("true","1","yes")

    # Admin (for lightweight password gate)
    ADMIN_PASSWORD = os.getenv("ADMIN_PASSWORD", "changeme")

    # Database
    SQLALCHEMY_DATABASE_URI = os.getenv("DATABASE_URL", "sqlite:///smartflow.db")
    SQLALCHEMY_TRACK_MODIFICATIONS = False

    # Stripe
    STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY")
    STRIPE_PUBLISHABLE_KEY = os.getenv("STRIPE_PUBLISHABLE_KEY")
    STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

    # Stripe Price IDs
    STRIPE_PRICE_STARTER_MONTHLY     = os.getenv("STRIPE_PRICE_STARTER_MONTHLY")
    STRIPE_PRICE_FLOWKIT_MONTHLY     = os.getenv("STRIPE_PRICE_FLOWKIT_MONTHLY")
    STRIPE_PRICE_LAUNCHPACK_MONTHLY  = os.getenv("STRIPE_PRICE_LAUNCHPACK_MONTHLY")
    STRIPE_PRICE_STARTER_ONEOFF      = os.getenv("STRIPE_PRICE_STARTER_ONEOFF")
    STRIPE_PRICE_FLOWKIT_ONEOFF      = os.getenv("STRIPE_PRICE_FLOWKIT_ONEOFF")
    STRIPE_PRICE_LAUNCHPACK_ONEOFF   = os.getenv("STRIPE_PRICE_LAUNCHPACK_ONEOFF")

    # Email (SMTP)
    SMTP_HOST = os.getenv("SMTP_HOST")
    SMTP_PORT = int(os.getenv("SMTP_PORT","587"))
    SMTP_USER = os.getenv("SMTP_USER")
    SMTP_PASS = os.getenv("SMTP_PASS")
    SMTP_FROM = os.getenv("SMTP_FROM","no-reply@smartflowsystems.com")

    # SMS: Vonage (Nexmo)
    VONAGE_API_KEY    = os.getenv("VONAGE_API_KEY")
    VONAGE_API_SECRET = os.getenv("VONAGE_API_SECRET")
    VONAGE_NUMBER     = os.getenv("VONAGE_NUMBER")

# Feature gating by plan
FEATURES_BY_PLAN = {
    "starter":   ["booking","basic_ai_bot","one_template"],
    "flowkit":   ["booking","ai_scheduler","sms","portal","two_templates","reports"],
    "launchpack":["booking","ai_scheduler","sms","portal","reports",
                  "ai_concierge","analytics","recovery","automations","three_templates","priority_support"]
}

========================================
4) db_models.py  (create/overwrite)
========================================
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
from sqlalchemy import UniqueConstraint

db = SQLAlchemy()

class Tenant(db.Model):
    __tablename__ = "tenants"
    id = db.Column(db.String(64), primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    owner_user_id = db.Column(db.String(64), index=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class User(db.Model):
    __tablename__ = "users"
    id = db.Column(db.String(64), primary_key=True)
    email = db.Column(db.String(255), unique=True, index=True, nullable=False)
    name = db.Column(db.String(200))
    status = db.Column(db.String(20), default="active") # active|suspended|deleted
    stripe_customer_id = db.Column(db.String(128), unique=True, index=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Membership(db.Model):
    __tablename__ = "memberships"
    tenant_id = db.Column(db.String(64), db.ForeignKey("tenants.id"), primary_key=True)
    user_id   = db.Column(db.String(64), db.ForeignKey("users.id"), primary_key=True)
    role      = db.Column(db.String(20), default="staff") # owner|admin|staff|analyst
    invited_at   = db.Column(db.DateTime)
    activated_at = db.Column(db.DateTime)

class Invitation(db.Model):
    __tablename__ = "invitations"
    id = db.Column(db.String(64), primary_key=True)
    tenant_id = db.Column(db.String(64), db.ForeignKey("tenants.id"))
    email = db.Column(db.String(255), index=True, nullable=False)
    role  = db.Column(db.String(20), nullable=False)
    token = db.Column(db.String(512), nullable=False)
    expires_at = db.Column(db.DateTime, nullable=False)
    status = db.Column(db.String(20), default="pending") # pending|accepted|expired
    inviter_user_id = db.Column(db.String(64))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class AuditLog(db.Model):
    __tablename__ = "audit_logs"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    tenant_id = db.Column(db.String(64), index=True)
    actor_user_id = db.Column(db.String(64), index=True)
    action = db.Column(db.String(64))
    target_type = db.Column(db.String(64))
    target_id = db.Column(db.String(64))
    metadata = db.Column(db.Text)   # JSON string
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class NotificationSettings(db.Model):
    __tablename__ = "notification_settings"
    tenant_id = db.Column(db.String(64), db.ForeignKey("tenants.id"), primary_key=True)
    email_enabled = db.Column(db.Boolean, default=True)
    sms_enabled = db.Column(db.Boolean, default=False)
    reminder_hours_before = db.Column(db.Integer, default=24)

class Booking(db.Model):
    __tablename__ = "bookings"
    id = db.Column(db.String(64), primary_key=True)
    tenant_id = db.Column(db.String(64), db.ForeignKey("tenants.id"), index=True)
    customer_name = db.Column(db.String(200))
    customer_email = db.Column(db.String(255))
    customer_phone = db.Column(db.String(40))
    start_at = db.Column(db.DateTime, index=True)  # UTC
    status = db.Column(db.String(20), default="confirmed")  # confirmed|cancelled|completed
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class ReminderLog(db.Model):
    __tablename__ = "reminder_logs"
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    tenant_id = db.Column(db.String(64), index=True)
    booking_id = db.Column(db.String(64), index=True)
    channel = db.Column(db.String(10))  # email|sms
    kind = db.Column(db.String(20), default="before")  # before|after
    sent_at = db.Column(db.DateTime, default=datetime.utcnow)
    __table_args__ = (UniqueConstraint('booking_id','channel','kind', name='uix_booking_channel_kind'),)

========================================
5) onboarding.py  (create/overwrite)  — email helper + simple template
========================================
import smtplib
from email.mime.text import MIMEText
from config import Config

def send_email_smtp(to_email: str, subject: str, body: str):
    if not (Config.SMTP_HOST and Config.SMTP_USER and Config.SMTP_PASS):
        print("[email] SMTP not configured; skipping.")
        return
    msg = MIMEText(body, "plain", "utf-8")
    msg["Subject"] = subject
    msg["From"] = Config.SMTP_FROM
    msg["To"] = to_email
    with smtplib.SMTP(Config.SMTP_HOST, Config.SMTP_PORT) as server:
        server.starttls()
        server.login(Config.SMTP_USER, Config.SMTP_PASS)
        server.sendmail(Config.SMTP_FROM, [to_email], msg.as_string())

def onboarding_email(plan: str):
    return f"""Welcome to SmartFlow Systems 👋

You're on the '{plan.title()}' plan.

Next steps:
1) Connect Google Calendar
2) Add brand colours (black+gold)
3) Enable reminders in Settings → Notifications
— Team SmartFlow
"""

========================================
6) sms.py  (create) — Vonage wrapper
========================================
import vonage
from typing import Optional
from config import Config

_client: Optional[vonage.Client] = None
_sms: Optional[vonage.Sms] = None

def _ensure_client():
    global _client, _sms
    if _client is None:
        if not (Config.VONAGE_API_KEY and Config.VONAGE_API_SECRET and Config.VONAGE_NUMBER):
            return False
        _client = vonage.Client(key=Config.VONAGE_API_KEY, secret=Config.VONAGE_API_SECRET)
        _sms = vonage.Sms(_client)
    return True

def send_sms(to_number: str, message: str) -> bool:
    if not _ensure_client():
        print("[sms] Vonage not configured; skipping.")
        return False
    try:
        resp = _sms.send_message({"from": Config.VONAGE_NUMBER, "to": to_number, "text": message})
        status = resp["messages"][0].get("status")
        if status == "0":
            print("[sms] sent.")
            return True
        print("[sms] failed:", resp["messages"][0].get("error-text"))
        return False
    except Exception as e:
        print("[sms] exception:", e)
        return False

========================================
7) app.py  (create/overwrite) — core app, UI, APIs, checkout, webhook, admin UI, settings, bookings, scheduler
========================================
import os, json, uuid
from datetime import datetime, timedelta
from functools import wraps
from flask import Flask, request, jsonify, render_template_string, redirect
from itsdangerous import URLSafeTimedSerializer, BadSignature, SignatureExpired
from apscheduler.schedulers.background import BackgroundScheduler
import stripe

from config import Config, FEATURES_BY_PLAN
from db_models import db, Tenant, User, Membership, Invitation, AuditLog, NotificationSettings, Booking, ReminderLog
from onboarding import send_email_smtp, onboarding_email
from sms import send_sms

app = Flask(__name__)
app.secret_key = Config.FLASK_SECRET_KEY
app.config["SQLALCHEMY_DATABASE_URI"] = Config.SQLALCHEMY_DATABASE_URI
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = Config.SQLALCHEMY_TRACK_MODIFICATIONS

db.init_app(app)
with app.app_context():
    db.create_all()

stripe.api_key = Config.STRIPE_SECRET_KEY
signer = URLSafeTimedSerializer(app.secret_key)

# ---------- Helpers ----------
def require_admin(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        pwd = request.args.get("p") or request.headers.get("X-Admin-Password")
        if pwd != Config.ADMIN_PASSWORD:
            return ("Forbidden: add ?p=<password> or X-Admin-Password header", 403)
        return fn(*args, **kwargs)
    return wrapper

def get_current_user():
    # Demo seed: one user + tenant
    u = User.query.filter_by(email="demo@smartflowsystems.com").first()
    if not u:
        u = User(id="demo-user", email="demo@smartflowsystems.com", name="Demo User")
        db.session.add(u); db.session.commit()
    t = Tenant.query.filter_by(id="demo-tenant").first()
    if not t:
        t = Tenant(id="demo-tenant", name="Demo Workspace", owner_user_id=u.id)
        db.session.add(t); db.session.commit()
        m = Membership(tenant_id=t.id, user_id=u.id, role="owner",
                       invited_at=datetime.utcnow(), activated_at=datetime.utcnow())
        db.session.add(m); db.session.commit()
    return u, t

def log_action(tenant_id, actor_user_id, action, target_type, target_id, metadata=None):
    rec = AuditLog(tenant_id=tenant_id, actor_user_id=actor_user_id, action=action,
                   target_type=target_type, target_id=target_id, metadata=json.dumps(metadata or {}))
    db.session.add(rec); db.session.commit()

def get_or_create_notif_settings(tenant_id: str) -> NotificationSettings:
    s = NotificationSettings.query.get(tenant_id)
    if not s:
        s = NotificationSettings(tenant_id=tenant_id)
        db.session.add(s); db.session.commit()
    return s

def notif_ok(tenant_id: str, channel: str) -> bool:
    s = get_or_create_notif_settings(tenant_id)
    if channel == "email":
        return bool(s.email_enabled)
    if channel == "sms":
        has_keys = bool(Config.VONAGE_API_KEY and Config.VONAGE_API_SECRET and Config.VONAGE_NUMBER)
        return bool(s.sms_enabled and has_keys)
    return False

def seat_limit_for_plan(plan:str) -> int:
    return {"starter":2,"flowkit":5,"launchpack":15}.get(plan, 2)

def tenant_active_seats(tenant_id:str) -> int:
    return Membership.query.filter_by(tenant_id=tenant_id).count()

def _price_for(plan, mode):
    mapping = {
        ("starter","monthly"):  Config.STRIPE_PRICE_STARTER_MONTHLY,
        ("flowkit","monthly"):  Config.STRIPE_PRICE_FLOWKIT_MONTHLY,
        ("launchpack","monthly"): Config.STRIPE_PRICE_LAUNCHPACK_MONTHLY,
        ("starter","oneoff"):   Config.STRIPE_PRICE_STARTER_ONEOFF,
        ("flowkit","oneoff"):   Config.STRIPE_PRICE_FLOWKIT_ONEOFF,
        ("launchpack","oneoff"): Config.STRIPE_PRICE_LAUNCHPACK_ONEOFF,
    }
    return mapping.get((plan,mode))

# ---------- UI: Landing & Pricing ----------
LANDING = """... black+gold HTML as in previous prompts (shortened for brevity) ..."""
PRICING = """... black+gold pricing HTML as in previous prompts (shortened for brevity) ..."""

@app.get("/")
def home(): return render_template_string(LANDING)

@app.get("/pricing")
def pricing(): return render_template_string(PRICING)

# ---------- Plan gating ----------
@app.get("/feature/<name>")
def feature_access(name):
    user, tenant = get_current_user()
    last = AuditLog.query.filter_by(tenant_id=tenant.id, action="plan_set").order_by(AuditLog.id.desc()).first()
    current_plan = (json.loads(last.metadata).get("plan") if last else "starter")
    ok = name in FEATURES_BY_PLAN.get(current_plan, [])
    return (jsonify({"ok":True,"feature":name,"plan":current_plan})
            if ok else (jsonify({"ok":False,"error":"Upgrade required","plan":current_plan}), 402))

# ---------- Stripe Checkout + Webhook ----------
@app.get("/checkout")
def checkout_redirect():
    plan = request.args.get("plan","starter")
    mode = request.args.get("mode","monthly")
    price_id = _price_for(plan, mode)
    if not price_id: return "Price not configured", 400
    user, tenant = get_current_user()
    session = stripe.checkout.Session.create(
        mode="subscription" if mode=="monthly" else "payment",
        line_items=[{"price": price_id, "quantity": 1}],
        success_url=request.host_url + "success?session_id={CHECKOUT_SESSION_ID}",
        cancel_url=request.host_url + "pricing",
        customer_email=user.email,
        metadata={"tenant_id":tenant.id,"app_user_id":user.id,"plan":plan,"mode":mode},
    )
    return redirect(session.url, code=303)

@app.get("/success")
def success():
    return "Payment successful — onboarding coming via email. Try /feature/ai_concierge."

@app.post("/webhooks/stripe")
def stripe_webhook():
    payload = request.data
    sig = request.headers.get("Stripe-Signature")
    try:
        event = stripe.Webhook.construct_event(payload, sig, Config.STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        return str(e), 400

    if event["type"] == "checkout.session.completed":
        session = event["data"]["object"]
        meta = session.get("metadata") or {}
        tenant_id = meta.get("tenant_id")
        plan = meta.get("plan","starter")
        log_action(tenant_id, meta.get("app_user_id"), "plan_set", "tenant", tenant_id, {"plan": plan})

        # Email onboarding (if enabled)
        if notif_ok(tenant_id, "email"):
            try:
                send_email_smtp(session["customer_details"]["email"], "Your SmartFlow plan is live", onboarding_email(plan))
            except Exception as e:
                print("[onboarding email] error:", e)

    return "", 200

# ---------- User Admin: Invite/Accept, List, Update ----------
from itsdangerous import URLSafeTimedSerializer
signer = URLSafeTimedSerializer(app.secret_key)

def generate_invite_token(payload:dict, expires_minutes=30):
    return signer.dumps(payload), datetime.utcnow() + timedelta(minutes=expires_minutes)

@app.post("/tenants/<tenant_id>/invites")
@require_admin
def create_invite(tenant_id):
    actor, tenant = get_current_user()
    if tenant_id != tenant.id: return ("Forbidden", 403)
    # plan seat check
    last = AuditLog.query.filter_by(tenant_id=tenant.id, action="plan_set").order_by(AuditLog.id.desc()).first()
    plan = (json.loads(last.metadata).get("plan") if last else "starter")
    if tenant_active_seats(tenant_id) >= seat_limit_for_plan(plan):
        return (jsonify({"ok":False,"error":"Seat limit reached. Upgrade plan."}), 402)
    data = request.get_json() or {}
    email = data.get("email"); role = data.get("role","staff")
    if not email: return ("email required", 400)
    token, exp = generate_invite_token({"tenant_id":tenant_id,"email":email,"role":role})
    inv = Invitation(id=str(uuid.uuid4()), tenant_id=tenant_id, email=email, role=role,
                     token=token, expires_at=exp, inviter_user_id=actor.id)
    db.session.add(inv); db.session.commit()
    link = request.host_url + "auth/accept?token=" + token
    try: send_email_smtp(email, "You're invited to SmartFlow", f"Join: {link}")
    except Exception as e: print("[invite email] error:", e)
    log_action(tenant_id, actor.id, "user.invited", "user", email, {"role":role})
    return jsonify({"ok":True,"invite_link":link})

@app.get("/auth/accept")
def accept_invite():
    token = request.args.get("token")
    try:
        data = signer.loads(token, max_age=60*30)
    except SignatureExpired: return "Invite expired", 410
    except BadSignature: return "Invalid token", 400
    tenant_id = data["tenant_id"]; email = data["email"]; role = data["role"]
    u = User.query.filter_by(email=email).first()
    if not u:
        u = User(id=email, email=email, name=email.split("@")[0])
        db.session.add(u); db.session.commit()
    m = Membership.query.filter_by(tenant_id=tenant_id, user_id=u.id).first()
    if not m:
        m = Membership(tenant_id=tenant_id, user_id=u.id, role=role,
                       invited_at=datetime.utcnow(), activated_at=datetime.utcnow())
        db.session.add(m); db.session.commit()
    log_action(tenant_id, u.id, "user.invite.accepted", "user", u.id, {"role":role})
    return "Invite accepted. You can close this page."

@app.patch("/tenants/<tenant_id>/users/<user_id>")
@require_admin
def change_role_or_suspend(tenant_id, user_id):
    actor, tenant = get_current_user()
    if tenant_id != tenant.id: return ("Forbidden", 403)
    data = request.get_json() or {}
    u = User.query.get(user_id)
    if not u: return ("User not found", 404)
    updates = {}
    if "role" in data:
        m = Membership.query.filter_by(tenant_id=tenant_id, user_id=user_id).first()
        if not m: return ("Membership not found", 404)
        old = m.role; m.role = data["role"]; db.session.commit()
        updates["role_before"] = old; updates["role_after"] = m.role
        log_action(tenant_id, actor.id, "user.role.changed", "user", user_id, updates)
    if "status" in data:
        old = u.status; u.status = data["status"]; db.session.commit()
        updates["status_before"] = old; updates["status_after"] = u.status
        log_action(tenant_id, actor.id, "user.status.changed", "user", user_id, updates)
    return jsonify({"ok":True,"updates":updates})

@app.get("/tenants/<tenant_id>/users")
@require_admin
def list_users(tenant_id):
    rows = (db.session.query(User, Membership)
            .join(Membership, Membership.user_id==User.id)
            .filter(Membership.tenant_id==tenant_id).all())
    out = [{"id":u.id,"email":u.email,"name":u.name,"status":u.status,"role":m.role} for u,m in rows]
    return jsonify(out)

# ---------- Admin Users UI ----------
ADMIN_USERS_HTML = """... black+gold HTML table with role editor, suspend/activate, invite (as in previous prompt) ..."""

@app.get("/admin/users")
@require_admin
def admin_users_page():
    return ADMIN_USERS_HTML

# ---------- Notifications API + Page ----------
def _admin_override_ok():
    return (request.args.get("p") == Config.ADMIN_PASSWORD) or (request.headers.get("X-Admin-Password") == Config.ADMIN_PASSWORD)

@app.get("/api/tenants/<tenant_id>/notifications")
def get_notifications(tenant_id):
    if not _admin_override_ok():
        u, t = get_current_user()
        if t.id != tenant_id: return ("Forbidden", 403)
    s = get_or_create_notif_settings(tenant_id)
    return {"tenant_id": tenant_id, "email_enabled": s.email_enabled, "sms_enabled": s.sms_enabled,
            "reminder_hours_before": s.reminder_hours_before}

@app.put("/api/tenants/<tenant_id>/notifications")
def update_notifications(tenant_id):
    if not _admin_override_ok():
        u, t = get_current_user()
        if t.id != tenant_id: return ("Forbidden", 403)
    data = request.get_json() or {}
    s = get_or_create_notif_settings(tenant_id)
    if "email_enabled" in data: s.email_enabled = bool(data["email_enabled"])
    if "sms_enabled" in data: s.sms_enabled = bool(data["sms_enabled"])
    if "reminder_hours_before" in data:
        try: s.reminder_hours_before = int(data["reminder_hours_before"])
        except: pass
    db.session.commit()
    log_action(tenant_id, "system", "notifications.updated", "tenant", tenant_id, {
        "email_enabled": s.email_enabled, "sms_enabled": s.sms_enabled,
        "reminder_hours_before": s.reminder_hours_before })
    return {"ok": True}

SETTINGS_HTML = """... black+gold notifications UI (toggles + timing) from previous prompt ..."""

@app.get("/settings/notifications")
def notifications_page():
    return SETTINGS_HTML

# ---------- Bookings API ----------
@app.post("/api/tenants/<tenant_id>/bookings")
def create_booking(tenant_id):
    data = request.get_json() or {}
    name = data.get("customer_name","Walk-in")
    email = data.get("customer_email")
    phone = data.get("customer_phone")
    start_at_iso = data.get("start_at")
    if not start_at_iso: return ("start_at (ISO) required", 400)
    try:
        start_at = datetime.fromisoformat(start_at_iso.replace("Z","+00:00")).replace(tzinfo=None)
    except Exception:
        return ("Invalid start_at format", 400)
    b = Booking(id=str(uuid.uuid4())[:12], tenant_id=tenant_id, customer_name=name,
                customer_email=email, customer_phone=phone, start_at=start_at, status="confirmed")
    db.session.add(b); db.session.commit()
    return {"ok": True, "booking_id": b.id}

@app.get("/api/tenants/<tenant_id>/bookings")
def list_bookings(tenant_id):
    now = datetime.utcnow()
    rows = (Booking.query
            .filter(Booking.tenant_id==tenant_id, Booking.start_at >= now, Booking.status=="confirmed")
            .order_by(Booking.start_at.asc()).limit(50).all())
    out = [{"id": b.id, "customer_name": b.customer_name, "email": b.customer_email,
            "phone": b.customer_phone, "start_at": b.start_at.isoformat()+"Z", "status": b.status} for b in rows]
    return out

# ---------- Scheduler: reminder worker ----------
def _send_booking_reminders():
    try:
        now = datetime.utcnow()
        tenant_ids = [t.id for t in Tenant.query.all()]
        for tid in tenant_ids:
            s = get_or_create_notif_settings(tid)
            hours = int(s.reminder_hours_before or 24)
            win_start = now + timedelta(hours=hours)
            win_end   = win_start + timedelta(minutes=5)
            candidates = (Booking.query
                          .filter(Booking.tenant_id==tid, Booking.status=="confirmed",
                                  Booking.start_at >= win_start, Booking.start_at < win_end).all())
            for b in candidates:
                # Email
                if notif_ok(tid, "email") and b.customer_email:
                    already = ReminderLog.query.filter_by(booking_id=b.id, channel="email", kind="before").first()
                    if not already:
                        try:
                            send_email_smtp(b.customer_email, "Appointment reminder",
                                            f"Reminder: {b.customer_name}, you have an appointment at {b.start_at}.")
                            db.session.add(ReminderLog(tenant_id=tid, booking_id=b.id, channel="email", kind="before"))
                            db.session.commit()
                        except Exception as e:
                            print("[reminder/email] error:", e)
                # SMS
                if notif_ok(tid, "sms") and b.customer_phone:
                    already = ReminderLog.query.filter_by(booking_id=b.id, channel="sms", kind="before").first()
                    if not already:
                        if send_sms(b.customer_phone, f"Reminder: your appointment is at {b.start_at}."):
                            db.session.add(ReminderLog(tenant_id=tid, booking_id=b.id, channel="sms", kind="before"))
                            db.session.commit()
    except Exception as e:
        print("[scheduler] loop error:", e)

scheduler = BackgroundScheduler(daemon=True)
scheduler.add_job(_send_booking_reminders, "interval", minutes=5, id="reminders_every_5m", replace_existing=True)
try: scheduler.start()
except Exception as e: print("[scheduler] start error:", e)

# ---------- Test Booking UI ----------
TEST_BOOKING_HTML = """... black+gold form UI from previous prompt (name/email/phone/datetime, posts to API) ..."""

@app.get("/test/booking")
def test_booking_page():
    return TEST_BOOKING_HTML

# ---------- Admin Users Page (HTML omitted for brevity in this block) ----------
# (Use the previously provided black+gold table page with role dropdown, suspend/activate, invite controls.)

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", 3000)))
========================================
8) Replit Secrets — create keys (values can be blank for now)
========================================
FLASK_SECRET_KEY
DEBUG="True"
ADMIN_PASSWORD=change-this

# Stripe (Test Mode)
STRIPE_SECRET_KEY
STRIPE_PUBLISHABLE_KEY
STRIPE_WEBHOOK_SECRET
STRIPE_PRICE_STARTER_MONTHLY
STRIPE_PRICE_FLOWKIT_MONTHLY
STRIPE_PRICE_LAUNCHPACK_MONTHLY
STRIPE_PRICE_STARTER_ONEOFF
STRIPE_PRICE_FLOWKIT_ONEOFF
STRIPE_PRICE_LAUNCHPACK_ONEOFF

# Email (SMTP)
SMTP_HOST
SMTP_PORT=587
SMTP_USER
SMTP_PASS
SMTP_FROM=no-reply@smartflowsystems.com

# Vonage (SMS)
VONAGE_API_KEY
VONAGE_API_SECRET
VONAGE_NUMBER

========================================
9) GitHub
========================================
- Open Git tab → Connect to GitHub (create private repo “smartflow-app”).
- Commit: "SmartFlow: base app + pricing + checkout + webhook + admin + Vonage SMS + notifications + bookings + scheduler"

========================================
10) Run & Verify
========================================
- Launch app.
- Visit /  and /pricing
- Stripe (Test Mode): create products & prices (GBP) and set price IDs in Secrets.
- Add webhook: https://<repl>/webhooks/stripe
  Events: checkout.session.completed, invoice.payment_succeeded, customer.subscription.deleted
  Set STRIPE_WEBHOOK_SECRET.

- Admin Users UI: /admin/users?p=ADMIN_PASSWORD
- Notifications: /settings/notifications?p=ADMIN_PASSWORD
- Create Test Booking: /test/booking (set ~24h in future to match reminder window)
- Reminders: scheduler runs every 5m; see emails/SMS and ReminderLog entries.

DONE.